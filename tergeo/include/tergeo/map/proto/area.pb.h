// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tergeo/map/proto/area.proto

#ifndef PROTOBUF_tergeo_2fmap_2fproto_2farea_2eproto__INCLUDED
#define PROTOBUF_tergeo_2fmap_2fproto_2farea_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "tergeo/map/proto/point_feature.pb.h"
#include "tergeo/map/proto/line_feature.pb.h"
#include "tergeo/map/proto/polyline_feature.pb.h"
#include "tergeo/map/proto/polygon_feature.pb.h"
// @@protoc_insertion_point(includes)

namespace tergeo {
namespace map {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tergeo_2fmap_2fproto_2farea_2eproto();
void protobuf_AssignDesc_tergeo_2fmap_2fproto_2farea_2eproto();
void protobuf_ShutdownFile_tergeo_2fmap_2fproto_2farea_2eproto();

class Area;
class Header;

// ===================================================================

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.map.proto.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  inline Header* New() const { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const void* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional bytes date = 2;
  bool has_date() const;
  void clear_date();
  static const int kDateFieldNumber = 2;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  void set_date(const char* value);
  void set_date(const void* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // optional bytes vendor = 3;
  bool has_vendor() const;
  void clear_vendor();
  static const int kVendorFieldNumber = 3;
  const ::std::string& vendor() const;
  void set_vendor(const ::std::string& value);
  void set_vendor(const char* value);
  void set_vendor(const void* value, size_t size);
  ::std::string* mutable_vendor();
  ::std::string* release_vendor();
  void set_allocated_vendor(::std::string* vendor);

  // @@protoc_insertion_point(class_scope:tergeo.map.proto.Header)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_vendor();
  inline void clear_has_vendor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr vendor_;
  friend void  protobuf_AddDesc_tergeo_2fmap_2fproto_2farea_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fmap_2fproto_2farea_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fmap_2fproto_2farea_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Area : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.map.proto.Area) */ {
 public:
  Area();
  virtual ~Area();

  Area(const Area& from);

  inline Area& operator=(const Area& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Area& default_instance();

  void Swap(Area* other);

  // implements Message ----------------------------------------------

  inline Area* New() const { return New(NULL); }

  Area* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Area& from);
  void MergeFrom(const Area& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Area* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tergeo.map.proto.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::tergeo::map::proto::Header& header() const;
  ::tergeo::map::proto::Header* mutable_header();
  ::tergeo::map::proto::Header* release_header();
  void set_allocated_header(::tergeo::map::proto::Header* header);

  // repeated .tergeo.map.proto.Signal signal = 2;
  int signal_size() const;
  void clear_signal();
  static const int kSignalFieldNumber = 2;
  const ::tergeo::map::proto::Signal& signal(int index) const;
  ::tergeo::map::proto::Signal* mutable_signal(int index);
  ::tergeo::map::proto::Signal* add_signal();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Signal >*
      mutable_signal();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Signal >&
      signal() const;

  // repeated .tergeo.map.proto.Tree tree = 3;
  int tree_size() const;
  void clear_tree();
  static const int kTreeFieldNumber = 3;
  const ::tergeo::map::proto::Tree& tree(int index) const;
  ::tergeo::map::proto::Tree* mutable_tree(int index);
  ::tergeo::map::proto::Tree* add_tree();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Tree >*
      mutable_tree();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Tree >&
      tree() const;

  // repeated .tergeo.map.proto.RoadEdge road_edge = 4;
  int road_edge_size() const;
  void clear_road_edge();
  static const int kRoadEdgeFieldNumber = 4;
  const ::tergeo::map::proto::RoadEdge& road_edge(int index) const;
  ::tergeo::map::proto::RoadEdge* mutable_road_edge(int index);
  ::tergeo::map::proto::RoadEdge* add_road_edge();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::RoadEdge >*
      mutable_road_edge();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::RoadEdge >&
      road_edge() const;

  // repeated .tergeo.map.proto.LaneLine lane_line = 5;
  int lane_line_size() const;
  void clear_lane_line();
  static const int kLaneLineFieldNumber = 5;
  const ::tergeo::map::proto::LaneLine& lane_line(int index) const;
  ::tergeo::map::proto::LaneLine* mutable_lane_line(int index);
  ::tergeo::map::proto::LaneLine* add_lane_line();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::LaneLine >*
      mutable_lane_line();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::LaneLine >&
      lane_line() const;

  // repeated .tergeo.map.proto.StopSign stop_sign = 6;
  int stop_sign_size() const;
  void clear_stop_sign();
  static const int kStopSignFieldNumber = 6;
  const ::tergeo::map::proto::StopSign& stop_sign(int index) const;
  ::tergeo::map::proto::StopSign* mutable_stop_sign(int index);
  ::tergeo::map::proto::StopSign* add_stop_sign();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::StopSign >*
      mutable_stop_sign();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::StopSign >&
      stop_sign() const;

  // repeated .tergeo.map.proto.SpeedBump speed_bump = 7;
  int speed_bump_size() const;
  void clear_speed_bump();
  static const int kSpeedBumpFieldNumber = 7;
  const ::tergeo::map::proto::SpeedBump& speed_bump(int index) const;
  ::tergeo::map::proto::SpeedBump* mutable_speed_bump(int index);
  ::tergeo::map::proto::SpeedBump* add_speed_bump();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::SpeedBump >*
      mutable_speed_bump();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::SpeedBump >&
      speed_bump() const;

  // repeated .tergeo.map.proto.Crosswalk crosswalk = 8;
  int crosswalk_size() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 8;
  const ::tergeo::map::proto::Crosswalk& crosswalk(int index) const;
  ::tergeo::map::proto::Crosswalk* mutable_crosswalk(int index);
  ::tergeo::map::proto::Crosswalk* add_crosswalk();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Crosswalk >*
      mutable_crosswalk();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Crosswalk >&
      crosswalk() const;

  // repeated .tergeo.map.proto.Junction junction = 9;
  int junction_size() const;
  void clear_junction();
  static const int kJunctionFieldNumber = 9;
  const ::tergeo::map::proto::Junction& junction(int index) const;
  ::tergeo::map::proto::Junction* mutable_junction(int index);
  ::tergeo::map::proto::Junction* add_junction();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Junction >*
      mutable_junction();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Junction >&
      junction() const;

  // repeated .tergeo.map.proto.ClearArea clear_area = 10;
  int clear_area_size() const;
  void clear_clear_area();
  static const int kClearAreaFieldNumber = 10;
  const ::tergeo::map::proto::ClearArea& clear_area(int index) const;
  ::tergeo::map::proto::ClearArea* mutable_clear_area(int index);
  ::tergeo::map::proto::ClearArea* add_clear_area();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ClearArea >*
      mutable_clear_area();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ClearArea >&
      clear_area() const;

  // repeated .tergeo.map.proto.ParkingSpace parking_space = 11;
  int parking_space_size() const;
  void clear_parking_space();
  static const int kParkingSpaceFieldNumber = 11;
  const ::tergeo::map::proto::ParkingSpace& parking_space(int index) const;
  ::tergeo::map::proto::ParkingSpace* mutable_parking_space(int index);
  ::tergeo::map::proto::ParkingSpace* add_parking_space();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ParkingSpace >*
      mutable_parking_space();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ParkingSpace >&
      parking_space() const;

  // repeated .tergeo.map.proto.Road road = 12;
  int road_size() const;
  void clear_road();
  static const int kRoadFieldNumber = 12;
  const ::tergeo::map::proto::Road& road(int index) const;
  ::tergeo::map::proto::Road* mutable_road(int index);
  ::tergeo::map::proto::Road* add_road();
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Road >*
      mutable_road();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Road >&
      road() const;

  // @@protoc_insertion_point(class_scope:tergeo.map.proto.Area)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tergeo::map::proto::Header* header_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Signal > signal_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Tree > tree_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::RoadEdge > road_edge_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::LaneLine > lane_line_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::StopSign > stop_sign_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::SpeedBump > speed_bump_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Crosswalk > crosswalk_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Junction > junction_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ClearArea > clear_area_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ParkingSpace > parking_space_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Road > road_;
  friend void  protobuf_AddDesc_tergeo_2fmap_2fproto_2farea_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fmap_2fproto_2farea_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fmap_2fproto_2farea_2eproto();

  void InitAsDefaultInstance();
  static Area* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Header

// optional bytes version = 1;
inline bool Header::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Header::version() const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Header.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.map.proto.Header.version)
}
inline void Header::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.map.proto.Header.version)
}
inline void Header::set_version(const void* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.map.proto.Header.version)
}
inline ::std::string* Header::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Header.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_version() {
  // @@protoc_insertion_point(field_release:tergeo.map.proto.Header.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:tergeo.map.proto.Header.version)
}

// optional bytes date = 2;
inline bool Header::has_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date();
}
inline const ::std::string& Header::date() const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Header.date)
  return date_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_date(const ::std::string& value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.map.proto.Header.date)
}
inline void Header::set_date(const char* value) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.map.proto.Header.date)
}
inline void Header::set_date(const void* value, size_t size) {
  set_has_date();
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.map.proto.Header.date)
}
inline ::std::string* Header::mutable_date() {
  set_has_date();
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Header.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_date() {
  // @@protoc_insertion_point(field_release:tergeo.map.proto.Header.date)
  clear_has_date();
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    set_has_date();
  } else {
    clear_has_date();
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:tergeo.map.proto.Header.date)
}

// optional bytes vendor = 3;
inline bool Header::has_vendor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_vendor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_vendor() {
  vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vendor();
}
inline const ::std::string& Header::vendor() const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Header.vendor)
  return vendor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_vendor(const ::std::string& value) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.map.proto.Header.vendor)
}
inline void Header::set_vendor(const char* value) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.map.proto.Header.vendor)
}
inline void Header::set_vendor(const void* value, size_t size) {
  set_has_vendor();
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.map.proto.Header.vendor)
}
inline ::std::string* Header::mutable_vendor() {
  set_has_vendor();
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Header.vendor)
  return vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_vendor() {
  // @@protoc_insertion_point(field_release:tergeo.map.proto.Header.vendor)
  clear_has_vendor();
  return vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_vendor(::std::string* vendor) {
  if (vendor != NULL) {
    set_has_vendor();
  } else {
    clear_has_vendor();
  }
  vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor);
  // @@protoc_insertion_point(field_set_allocated:tergeo.map.proto.Header.vendor)
}

// -------------------------------------------------------------------

// Area

// optional .tergeo.map.proto.Header header = 1;
inline bool Area::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Area::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Area::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Area::clear_header() {
  if (header_ != NULL) header_->::tergeo::map::proto::Header::Clear();
  clear_has_header();
}
inline const ::tergeo::map::proto::Header& Area::header() const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::tergeo::map::proto::Header* Area::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::tergeo::map::proto::Header;
  }
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.header)
  return header_;
}
inline ::tergeo::map::proto::Header* Area::release_header() {
  // @@protoc_insertion_point(field_release:tergeo.map.proto.Area.header)
  clear_has_header();
  ::tergeo::map::proto::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Area::set_allocated_header(::tergeo::map::proto::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:tergeo.map.proto.Area.header)
}

// repeated .tergeo.map.proto.Signal signal = 2;
inline int Area::signal_size() const {
  return signal_.size();
}
inline void Area::clear_signal() {
  signal_.Clear();
}
inline const ::tergeo::map::proto::Signal& Area::signal(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.signal)
  return signal_.Get(index);
}
inline ::tergeo::map::proto::Signal* Area::mutable_signal(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.signal)
  return signal_.Mutable(index);
}
inline ::tergeo::map::proto::Signal* Area::add_signal() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.signal)
  return signal_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Signal >*
Area::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.signal)
  return &signal_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Signal >&
Area::signal() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.signal)
  return signal_;
}

// repeated .tergeo.map.proto.Tree tree = 3;
inline int Area::tree_size() const {
  return tree_.size();
}
inline void Area::clear_tree() {
  tree_.Clear();
}
inline const ::tergeo::map::proto::Tree& Area::tree(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.tree)
  return tree_.Get(index);
}
inline ::tergeo::map::proto::Tree* Area::mutable_tree(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.tree)
  return tree_.Mutable(index);
}
inline ::tergeo::map::proto::Tree* Area::add_tree() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.tree)
  return tree_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Tree >*
Area::mutable_tree() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.tree)
  return &tree_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Tree >&
Area::tree() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.tree)
  return tree_;
}

// repeated .tergeo.map.proto.RoadEdge road_edge = 4;
inline int Area::road_edge_size() const {
  return road_edge_.size();
}
inline void Area::clear_road_edge() {
  road_edge_.Clear();
}
inline const ::tergeo::map::proto::RoadEdge& Area::road_edge(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.road_edge)
  return road_edge_.Get(index);
}
inline ::tergeo::map::proto::RoadEdge* Area::mutable_road_edge(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.road_edge)
  return road_edge_.Mutable(index);
}
inline ::tergeo::map::proto::RoadEdge* Area::add_road_edge() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.road_edge)
  return road_edge_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::RoadEdge >*
Area::mutable_road_edge() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.road_edge)
  return &road_edge_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::RoadEdge >&
Area::road_edge() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.road_edge)
  return road_edge_;
}

// repeated .tergeo.map.proto.LaneLine lane_line = 5;
inline int Area::lane_line_size() const {
  return lane_line_.size();
}
inline void Area::clear_lane_line() {
  lane_line_.Clear();
}
inline const ::tergeo::map::proto::LaneLine& Area::lane_line(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.lane_line)
  return lane_line_.Get(index);
}
inline ::tergeo::map::proto::LaneLine* Area::mutable_lane_line(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.lane_line)
  return lane_line_.Mutable(index);
}
inline ::tergeo::map::proto::LaneLine* Area::add_lane_line() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.lane_line)
  return lane_line_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::LaneLine >*
Area::mutable_lane_line() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.lane_line)
  return &lane_line_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::LaneLine >&
Area::lane_line() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.lane_line)
  return lane_line_;
}

// repeated .tergeo.map.proto.StopSign stop_sign = 6;
inline int Area::stop_sign_size() const {
  return stop_sign_.size();
}
inline void Area::clear_stop_sign() {
  stop_sign_.Clear();
}
inline const ::tergeo::map::proto::StopSign& Area::stop_sign(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.stop_sign)
  return stop_sign_.Get(index);
}
inline ::tergeo::map::proto::StopSign* Area::mutable_stop_sign(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.stop_sign)
  return stop_sign_.Mutable(index);
}
inline ::tergeo::map::proto::StopSign* Area::add_stop_sign() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.stop_sign)
  return stop_sign_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::StopSign >*
Area::mutable_stop_sign() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.stop_sign)
  return &stop_sign_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::StopSign >&
Area::stop_sign() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.stop_sign)
  return stop_sign_;
}

// repeated .tergeo.map.proto.SpeedBump speed_bump = 7;
inline int Area::speed_bump_size() const {
  return speed_bump_.size();
}
inline void Area::clear_speed_bump() {
  speed_bump_.Clear();
}
inline const ::tergeo::map::proto::SpeedBump& Area::speed_bump(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.speed_bump)
  return speed_bump_.Get(index);
}
inline ::tergeo::map::proto::SpeedBump* Area::mutable_speed_bump(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.speed_bump)
  return speed_bump_.Mutable(index);
}
inline ::tergeo::map::proto::SpeedBump* Area::add_speed_bump() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.speed_bump)
  return speed_bump_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::SpeedBump >*
Area::mutable_speed_bump() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.speed_bump)
  return &speed_bump_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::SpeedBump >&
Area::speed_bump() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.speed_bump)
  return speed_bump_;
}

// repeated .tergeo.map.proto.Crosswalk crosswalk = 8;
inline int Area::crosswalk_size() const {
  return crosswalk_.size();
}
inline void Area::clear_crosswalk() {
  crosswalk_.Clear();
}
inline const ::tergeo::map::proto::Crosswalk& Area::crosswalk(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.crosswalk)
  return crosswalk_.Get(index);
}
inline ::tergeo::map::proto::Crosswalk* Area::mutable_crosswalk(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.crosswalk)
  return crosswalk_.Mutable(index);
}
inline ::tergeo::map::proto::Crosswalk* Area::add_crosswalk() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.crosswalk)
  return crosswalk_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Crosswalk >*
Area::mutable_crosswalk() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.crosswalk)
  return &crosswalk_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Crosswalk >&
Area::crosswalk() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.crosswalk)
  return crosswalk_;
}

// repeated .tergeo.map.proto.Junction junction = 9;
inline int Area::junction_size() const {
  return junction_.size();
}
inline void Area::clear_junction() {
  junction_.Clear();
}
inline const ::tergeo::map::proto::Junction& Area::junction(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.junction)
  return junction_.Get(index);
}
inline ::tergeo::map::proto::Junction* Area::mutable_junction(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.junction)
  return junction_.Mutable(index);
}
inline ::tergeo::map::proto::Junction* Area::add_junction() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.junction)
  return junction_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Junction >*
Area::mutable_junction() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.junction)
  return &junction_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Junction >&
Area::junction() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.junction)
  return junction_;
}

// repeated .tergeo.map.proto.ClearArea clear_area = 10;
inline int Area::clear_area_size() const {
  return clear_area_.size();
}
inline void Area::clear_clear_area() {
  clear_area_.Clear();
}
inline const ::tergeo::map::proto::ClearArea& Area::clear_area(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.clear_area)
  return clear_area_.Get(index);
}
inline ::tergeo::map::proto::ClearArea* Area::mutable_clear_area(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.clear_area)
  return clear_area_.Mutable(index);
}
inline ::tergeo::map::proto::ClearArea* Area::add_clear_area() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.clear_area)
  return clear_area_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ClearArea >*
Area::mutable_clear_area() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.clear_area)
  return &clear_area_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ClearArea >&
Area::clear_area() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.clear_area)
  return clear_area_;
}

// repeated .tergeo.map.proto.ParkingSpace parking_space = 11;
inline int Area::parking_space_size() const {
  return parking_space_.size();
}
inline void Area::clear_parking_space() {
  parking_space_.Clear();
}
inline const ::tergeo::map::proto::ParkingSpace& Area::parking_space(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.parking_space)
  return parking_space_.Get(index);
}
inline ::tergeo::map::proto::ParkingSpace* Area::mutable_parking_space(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.parking_space)
  return parking_space_.Mutable(index);
}
inline ::tergeo::map::proto::ParkingSpace* Area::add_parking_space() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.parking_space)
  return parking_space_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ParkingSpace >*
Area::mutable_parking_space() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.parking_space)
  return &parking_space_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::ParkingSpace >&
Area::parking_space() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.parking_space)
  return parking_space_;
}

// repeated .tergeo.map.proto.Road road = 12;
inline int Area::road_size() const {
  return road_.size();
}
inline void Area::clear_road() {
  road_.Clear();
}
inline const ::tergeo::map::proto::Road& Area::road(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.map.proto.Area.road)
  return road_.Get(index);
}
inline ::tergeo::map::proto::Road* Area::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.map.proto.Area.road)
  return road_.Mutable(index);
}
inline ::tergeo::map::proto::Road* Area::add_road() {
  // @@protoc_insertion_point(field_add:tergeo.map.proto.Area.road)
  return road_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Road >*
Area::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.map.proto.Area.road)
  return &road_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::map::proto::Road >&
Area::road() const {
  // @@protoc_insertion_point(field_list:tergeo.map.proto.Area.road)
  return road_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace map
}  // namespace tergeo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tergeo_2fmap_2fproto_2farea_2eproto__INCLUDED
