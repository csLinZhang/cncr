// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tergeo/pipeline/proto/task.proto

#ifndef PROTOBUF_tergeo_2fpipeline_2fproto_2ftask_2eproto__INCLUDED
#define PROTOBUF_tergeo_2fpipeline_2fproto_2ftask_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tergeo {
namespace pipeline {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tergeo_2fpipeline_2fproto_2ftask_2eproto();
void protobuf_AssignDesc_tergeo_2fpipeline_2fproto_2ftask_2eproto();
void protobuf_ShutdownFile_tergeo_2fpipeline_2fproto_2ftask_2eproto();

class GoalPoint;
class Task;
class TaskList;

enum TaskMode {
  MODE_TRACKING = 0,
  MODE_MOVE_TO_GOAL = 1,
  MODE_MOVE_COVERAGE = 2
};
bool TaskMode_IsValid(int value);
const TaskMode TaskMode_MIN = MODE_TRACKING;
const TaskMode TaskMode_MAX = MODE_MOVE_COVERAGE;
const int TaskMode_ARRAYSIZE = TaskMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskMode_descriptor();
inline const ::std::string& TaskMode_Name(TaskMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskMode_descriptor(), value);
}
inline bool TaskMode_Parse(
    const ::std::string& name, TaskMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskMode>(
    TaskMode_descriptor(), name, value);
}
enum TaskType {
  TYPE_NULL = 0,
  TYPE_CLEAN_WORK = 1,
  TYPE_CHARGE = 2
};
bool TaskType_IsValid(int value);
const TaskType TaskType_MIN = TYPE_NULL;
const TaskType TaskType_MAX = TYPE_CHARGE;
const int TaskType_ARRAYSIZE = TaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskType_descriptor();
inline const ::std::string& TaskType_Name(TaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskType_descriptor(), value);
}
inline bool TaskType_Parse(
    const ::std::string& name, TaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskType>(
    TaskType_descriptor(), name, value);
}
enum TaskStatus {
  STATUS_UNKNOWN = 0,
  STATUS_WAITTING = 1,
  STATUS_PREPARE = 2,
  STATUS_PROCESSING = 3,
  STATUS_DONE = 4,
  STATUS_ERROR = 5
};
bool TaskStatus_IsValid(int value);
const TaskStatus TaskStatus_MIN = STATUS_UNKNOWN;
const TaskStatus TaskStatus_MAX = STATUS_ERROR;
const int TaskStatus_ARRAYSIZE = TaskStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TaskStatus_descriptor();
inline const ::std::string& TaskStatus_Name(TaskStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TaskStatus_descriptor(), value);
}
inline bool TaskStatus_Parse(
    const ::std::string& name, TaskStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TaskStatus>(
    TaskStatus_descriptor(), name, value);
}
enum SceneType {
  SCENE_UNKNOWN = 0,
  SCENE_OPEN_SPACE = 1,
  SCENE_ROAD_EDGE = 2,
  SCENE_ALONG_WALL = 3,
  SCENE_NARROW_PATH = 4,
  SCENE_UTURN = 5
};
bool SceneType_IsValid(int value);
const SceneType SceneType_MIN = SCENE_UNKNOWN;
const SceneType SceneType_MAX = SCENE_UTURN;
const int SceneType_ARRAYSIZE = SceneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SceneType_descriptor();
inline const ::std::string& SceneType_Name(SceneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SceneType_descriptor(), value);
}
inline bool SceneType_Parse(
    const ::std::string& name, SceneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneType>(
    SceneType_descriptor(), name, value);
}
// ===================================================================

class GoalPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.pipeline.proto.GoalPoint) */ {
 public:
  GoalPoint();
  virtual ~GoalPoint();

  GoalPoint(const GoalPoint& from);

  inline GoalPoint& operator=(const GoalPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoalPoint& default_instance();

  void Swap(GoalPoint* other);

  // implements Message ----------------------------------------------

  inline GoalPoint* New() const { return New(NULL); }

  GoalPoint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GoalPoint& from);
  void MergeFrom(const GoalPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GoalPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double theta = 3;
  bool has_theta() const;
  void clear_theta();
  static const int kThetaFieldNumber = 3;
  double theta() const;
  void set_theta(double value);

  // @@protoc_insertion_point(class_scope:tergeo.pipeline.proto.GoalPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_theta();
  inline void clear_has_theta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double theta_;
  friend void  protobuf_AddDesc_tergeo_2fpipeline_2fproto_2ftask_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fpipeline_2fproto_2ftask_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fpipeline_2fproto_2ftask_2eproto();

  void InitAsDefaultInstance();
  static GoalPoint* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.pipeline.proto.Task) */ {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  inline Task* New() const { return New(NULL); }

  Task* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Task* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string describe = 3;
  bool has_describe() const;
  void clear_describe();
  static const int kDescribeFieldNumber = 3;
  const ::std::string& describe() const;
  void set_describe(const ::std::string& value);
  void set_describe(const char* value);
  void set_describe(const char* value, size_t size);
  ::std::string* mutable_describe();
  ::std::string* release_describe();
  void set_allocated_describe(::std::string* describe);

  // optional int32 priority = 4;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 4;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // optional .tergeo.pipeline.proto.TaskMode task_mode = 5;
  bool has_task_mode() const;
  void clear_task_mode();
  static const int kTaskModeFieldNumber = 5;
  ::tergeo::pipeline::proto::TaskMode task_mode() const;
  void set_task_mode(::tergeo::pipeline::proto::TaskMode value);

  // optional .tergeo.pipeline.proto.TaskType task_type = 6;
  bool has_task_type() const;
  void clear_task_type();
  static const int kTaskTypeFieldNumber = 6;
  ::tergeo::pipeline::proto::TaskType task_type() const;
  void set_task_type(::tergeo::pipeline::proto::TaskType value);

  // optional .tergeo.pipeline.proto.SceneType scene_type = 7;
  bool has_scene_type() const;
  void clear_scene_type();
  static const int kSceneTypeFieldNumber = 7;
  ::tergeo::pipeline::proto::SceneType scene_type() const;
  void set_scene_type(::tergeo::pipeline::proto::SceneType value);

  // optional bool enable_avoid_obstacle = 8;
  bool has_enable_avoid_obstacle() const;
  void clear_enable_avoid_obstacle();
  static const int kEnableAvoidObstacleFieldNumber = 8;
  bool enable_avoid_obstacle() const;
  void set_enable_avoid_obstacle(bool value);

  // optional bool enable = 9;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 9;
  bool enable() const;
  void set_enable(bool value);

  // optional .tergeo.pipeline.proto.GoalPoint goal_point = 10;
  bool has_goal_point() const;
  void clear_goal_point();
  static const int kGoalPointFieldNumber = 10;
  const ::tergeo::pipeline::proto::GoalPoint& goal_point() const;
  ::tergeo::pipeline::proto::GoalPoint* mutable_goal_point();
  ::tergeo::pipeline::proto::GoalPoint* release_goal_point();
  void set_allocated_goal_point(::tergeo::pipeline::proto::GoalPoint* goal_point);

  // optional string ref_line_name = 11;
  bool has_ref_line_name() const;
  void clear_ref_line_name();
  static const int kRefLineNameFieldNumber = 11;
  const ::std::string& ref_line_name() const;
  void set_ref_line_name(const ::std::string& value);
  void set_ref_line_name(const char* value);
  void set_ref_line_name(const char* value, size_t size);
  ::std::string* mutable_ref_line_name();
  ::std::string* release_ref_line_name();
  void set_allocated_ref_line_name(::std::string* ref_line_name);

  // optional string map_area_name = 12;
  bool has_map_area_name() const;
  void clear_map_area_name();
  static const int kMapAreaNameFieldNumber = 12;
  const ::std::string& map_area_name() const;
  void set_map_area_name(const ::std::string& value);
  void set_map_area_name(const char* value);
  void set_map_area_name(const char* value, size_t size);
  ::std::string* mutable_map_area_name();
  ::std::string* release_map_area_name();
  void set_allocated_map_area_name(::std::string* map_area_name);

  // optional .tergeo.pipeline.proto.TaskStatus status = 13;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 13;
  ::tergeo::pipeline::proto::TaskStatus status() const;
  void set_status(::tergeo::pipeline::proto::TaskStatus value);

  // @@protoc_insertion_point(class_scope:tergeo.pipeline.proto.Task)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_describe();
  inline void clear_has_describe();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_task_mode();
  inline void clear_has_task_mode();
  inline void set_has_task_type();
  inline void clear_has_task_type();
  inline void set_has_scene_type();
  inline void clear_has_scene_type();
  inline void set_has_enable_avoid_obstacle();
  inline void clear_has_enable_avoid_obstacle();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_goal_point();
  inline void clear_has_goal_point();
  inline void set_has_ref_line_name();
  inline void clear_has_ref_line_name();
  inline void set_has_map_area_name();
  inline void clear_has_map_area_name();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr describe_;
  ::google::protobuf::int32 priority_;
  int task_mode_;
  int task_type_;
  int scene_type_;
  ::tergeo::pipeline::proto::GoalPoint* goal_point_;
  bool enable_avoid_obstacle_;
  bool enable_;
  int status_;
  ::google::protobuf::internal::ArenaStringPtr ref_line_name_;
  ::google::protobuf::internal::ArenaStringPtr map_area_name_;
  friend void  protobuf_AddDesc_tergeo_2fpipeline_2fproto_2ftask_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fpipeline_2fproto_2ftask_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fpipeline_2fproto_2ftask_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class TaskList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.pipeline.proto.TaskList) */ {
 public:
  TaskList();
  virtual ~TaskList();

  TaskList(const TaskList& from);

  inline TaskList& operator=(const TaskList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskList& default_instance();

  void Swap(TaskList* other);

  // implements Message ----------------------------------------------

  inline TaskList* New() const { return New(NULL); }

  TaskList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskList& from);
  void MergeFrom(const TaskList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TaskList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tergeo.pipeline.proto.Task task = 1;
  int task_size() const;
  void clear_task();
  static const int kTaskFieldNumber = 1;
  const ::tergeo::pipeline::proto::Task& task(int index) const;
  ::tergeo::pipeline::proto::Task* mutable_task(int index);
  ::tergeo::pipeline::proto::Task* add_task();
  ::google::protobuf::RepeatedPtrField< ::tergeo::pipeline::proto::Task >*
      mutable_task();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::pipeline::proto::Task >&
      task() const;

  // @@protoc_insertion_point(class_scope:tergeo.pipeline.proto.TaskList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::pipeline::proto::Task > task_;
  friend void  protobuf_AddDesc_tergeo_2fpipeline_2fproto_2ftask_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fpipeline_2fproto_2ftask_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fpipeline_2fproto_2ftask_2eproto();

  void InitAsDefaultInstance();
  static TaskList* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GoalPoint

// optional double x = 1;
inline bool GoalPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoalPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoalPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoalPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double GoalPoint::x() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.GoalPoint.x)
  return x_;
}
inline void GoalPoint::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.GoalPoint.x)
}

// optional double y = 2;
inline bool GoalPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoalPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoalPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoalPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double GoalPoint::y() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.GoalPoint.y)
  return y_;
}
inline void GoalPoint::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.GoalPoint.y)
}

// optional double theta = 3;
inline bool GoalPoint::has_theta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoalPoint::set_has_theta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoalPoint::clear_has_theta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoalPoint::clear_theta() {
  theta_ = 0;
  clear_has_theta();
}
inline double GoalPoint::theta() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.GoalPoint.theta)
  return theta_;
}
inline void GoalPoint::set_theta(double value) {
  set_has_theta();
  theta_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.GoalPoint.theta)
}

// -------------------------------------------------------------------

// Task

// optional string id = 1;
inline bool Task::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Task::id() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.id)
}
inline void Task::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.pipeline.proto.Task.id)
}
inline void Task::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.pipeline.proto.Task.id)
}
inline ::std::string* Task::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:tergeo.pipeline.proto.Task.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_id() {
  // @@protoc_insertion_point(field_release:tergeo.pipeline.proto.Task.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:tergeo.pipeline.proto.Task.id)
}

// optional string name = 2;
inline bool Task::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.name)
}
inline void Task::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.pipeline.proto.Task.name)
}
inline void Task::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.pipeline.proto.Task.name)
}
inline ::std::string* Task::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tergeo.pipeline.proto.Task.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_name() {
  // @@protoc_insertion_point(field_release:tergeo.pipeline.proto.Task.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tergeo.pipeline.proto.Task.name)
}

// optional string describe = 3;
inline bool Task::has_describe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_describe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_describe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_describe() {
  describe_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_describe();
}
inline const ::std::string& Task::describe() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.describe)
  return describe_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_describe(const ::std::string& value) {
  set_has_describe();
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.describe)
}
inline void Task::set_describe(const char* value) {
  set_has_describe();
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.pipeline.proto.Task.describe)
}
inline void Task::set_describe(const char* value, size_t size) {
  set_has_describe();
  describe_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.pipeline.proto.Task.describe)
}
inline ::std::string* Task::mutable_describe() {
  set_has_describe();
  // @@protoc_insertion_point(field_mutable:tergeo.pipeline.proto.Task.describe)
  return describe_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_describe() {
  // @@protoc_insertion_point(field_release:tergeo.pipeline.proto.Task.describe)
  clear_has_describe();
  return describe_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_describe(::std::string* describe) {
  if (describe != NULL) {
    set_has_describe();
  } else {
    clear_has_describe();
  }
  describe_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), describe);
  // @@protoc_insertion_point(field_set_allocated:tergeo.pipeline.proto.Task.describe)
}

// optional int32 priority = 4;
inline bool Task::has_priority() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_priority() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_priority() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_priority() {
  priority_ = 0;
  clear_has_priority();
}
inline ::google::protobuf::int32 Task::priority() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.priority)
  return priority_;
}
inline void Task::set_priority(::google::protobuf::int32 value) {
  set_has_priority();
  priority_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.priority)
}

// optional .tergeo.pipeline.proto.TaskMode task_mode = 5;
inline bool Task::has_task_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Task::set_has_task_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Task::clear_has_task_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Task::clear_task_mode() {
  task_mode_ = 0;
  clear_has_task_mode();
}
inline ::tergeo::pipeline::proto::TaskMode Task::task_mode() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.task_mode)
  return static_cast< ::tergeo::pipeline::proto::TaskMode >(task_mode_);
}
inline void Task::set_task_mode(::tergeo::pipeline::proto::TaskMode value) {
  assert(::tergeo::pipeline::proto::TaskMode_IsValid(value));
  set_has_task_mode();
  task_mode_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.task_mode)
}

// optional .tergeo.pipeline.proto.TaskType task_type = 6;
inline bool Task::has_task_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Task::set_has_task_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Task::clear_has_task_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Task::clear_task_type() {
  task_type_ = 0;
  clear_has_task_type();
}
inline ::tergeo::pipeline::proto::TaskType Task::task_type() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.task_type)
  return static_cast< ::tergeo::pipeline::proto::TaskType >(task_type_);
}
inline void Task::set_task_type(::tergeo::pipeline::proto::TaskType value) {
  assert(::tergeo::pipeline::proto::TaskType_IsValid(value));
  set_has_task_type();
  task_type_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.task_type)
}

// optional .tergeo.pipeline.proto.SceneType scene_type = 7;
inline bool Task::has_scene_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Task::set_has_scene_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Task::clear_has_scene_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Task::clear_scene_type() {
  scene_type_ = 0;
  clear_has_scene_type();
}
inline ::tergeo::pipeline::proto::SceneType Task::scene_type() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.scene_type)
  return static_cast< ::tergeo::pipeline::proto::SceneType >(scene_type_);
}
inline void Task::set_scene_type(::tergeo::pipeline::proto::SceneType value) {
  assert(::tergeo::pipeline::proto::SceneType_IsValid(value));
  set_has_scene_type();
  scene_type_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.scene_type)
}

// optional bool enable_avoid_obstacle = 8;
inline bool Task::has_enable_avoid_obstacle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Task::set_has_enable_avoid_obstacle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Task::clear_has_enable_avoid_obstacle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Task::clear_enable_avoid_obstacle() {
  enable_avoid_obstacle_ = false;
  clear_has_enable_avoid_obstacle();
}
inline bool Task::enable_avoid_obstacle() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.enable_avoid_obstacle)
  return enable_avoid_obstacle_;
}
inline void Task::set_enable_avoid_obstacle(bool value) {
  set_has_enable_avoid_obstacle();
  enable_avoid_obstacle_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.enable_avoid_obstacle)
}

// optional bool enable = 9;
inline bool Task::has_enable() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Task::set_has_enable() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Task::clear_has_enable() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Task::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool Task::enable() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.enable)
  return enable_;
}
inline void Task::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.enable)
}

// optional .tergeo.pipeline.proto.GoalPoint goal_point = 10;
inline bool Task::has_goal_point() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Task::set_has_goal_point() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Task::clear_has_goal_point() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Task::clear_goal_point() {
  if (goal_point_ != NULL) goal_point_->::tergeo::pipeline::proto::GoalPoint::Clear();
  clear_has_goal_point();
}
inline const ::tergeo::pipeline::proto::GoalPoint& Task::goal_point() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.goal_point)
  return goal_point_ != NULL ? *goal_point_ : *default_instance_->goal_point_;
}
inline ::tergeo::pipeline::proto::GoalPoint* Task::mutable_goal_point() {
  set_has_goal_point();
  if (goal_point_ == NULL) {
    goal_point_ = new ::tergeo::pipeline::proto::GoalPoint;
  }
  // @@protoc_insertion_point(field_mutable:tergeo.pipeline.proto.Task.goal_point)
  return goal_point_;
}
inline ::tergeo::pipeline::proto::GoalPoint* Task::release_goal_point() {
  // @@protoc_insertion_point(field_release:tergeo.pipeline.proto.Task.goal_point)
  clear_has_goal_point();
  ::tergeo::pipeline::proto::GoalPoint* temp = goal_point_;
  goal_point_ = NULL;
  return temp;
}
inline void Task::set_allocated_goal_point(::tergeo::pipeline::proto::GoalPoint* goal_point) {
  delete goal_point_;
  goal_point_ = goal_point;
  if (goal_point) {
    set_has_goal_point();
  } else {
    clear_has_goal_point();
  }
  // @@protoc_insertion_point(field_set_allocated:tergeo.pipeline.proto.Task.goal_point)
}

// optional string ref_line_name = 11;
inline bool Task::has_ref_line_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Task::set_has_ref_line_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Task::clear_has_ref_line_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Task::clear_ref_line_name() {
  ref_line_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ref_line_name();
}
inline const ::std::string& Task::ref_line_name() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.ref_line_name)
  return ref_line_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_ref_line_name(const ::std::string& value) {
  set_has_ref_line_name();
  ref_line_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.ref_line_name)
}
inline void Task::set_ref_line_name(const char* value) {
  set_has_ref_line_name();
  ref_line_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.pipeline.proto.Task.ref_line_name)
}
inline void Task::set_ref_line_name(const char* value, size_t size) {
  set_has_ref_line_name();
  ref_line_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.pipeline.proto.Task.ref_line_name)
}
inline ::std::string* Task::mutable_ref_line_name() {
  set_has_ref_line_name();
  // @@protoc_insertion_point(field_mutable:tergeo.pipeline.proto.Task.ref_line_name)
  return ref_line_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_ref_line_name() {
  // @@protoc_insertion_point(field_release:tergeo.pipeline.proto.Task.ref_line_name)
  clear_has_ref_line_name();
  return ref_line_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_ref_line_name(::std::string* ref_line_name) {
  if (ref_line_name != NULL) {
    set_has_ref_line_name();
  } else {
    clear_has_ref_line_name();
  }
  ref_line_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_line_name);
  // @@protoc_insertion_point(field_set_allocated:tergeo.pipeline.proto.Task.ref_line_name)
}

// optional string map_area_name = 12;
inline bool Task::has_map_area_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Task::set_has_map_area_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Task::clear_has_map_area_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Task::clear_map_area_name() {
  map_area_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_map_area_name();
}
inline const ::std::string& Task::map_area_name() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.map_area_name)
  return map_area_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_map_area_name(const ::std::string& value) {
  set_has_map_area_name();
  map_area_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.map_area_name)
}
inline void Task::set_map_area_name(const char* value) {
  set_has_map_area_name();
  map_area_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.pipeline.proto.Task.map_area_name)
}
inline void Task::set_map_area_name(const char* value, size_t size) {
  set_has_map_area_name();
  map_area_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.pipeline.proto.Task.map_area_name)
}
inline ::std::string* Task::mutable_map_area_name() {
  set_has_map_area_name();
  // @@protoc_insertion_point(field_mutable:tergeo.pipeline.proto.Task.map_area_name)
  return map_area_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_map_area_name() {
  // @@protoc_insertion_point(field_release:tergeo.pipeline.proto.Task.map_area_name)
  clear_has_map_area_name();
  return map_area_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_map_area_name(::std::string* map_area_name) {
  if (map_area_name != NULL) {
    set_has_map_area_name();
  } else {
    clear_has_map_area_name();
  }
  map_area_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_area_name);
  // @@protoc_insertion_point(field_set_allocated:tergeo.pipeline.proto.Task.map_area_name)
}

// optional .tergeo.pipeline.proto.TaskStatus status = 13;
inline bool Task::has_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Task::set_has_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Task::clear_has_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Task::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::tergeo::pipeline::proto::TaskStatus Task::status() const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.Task.status)
  return static_cast< ::tergeo::pipeline::proto::TaskStatus >(status_);
}
inline void Task::set_status(::tergeo::pipeline::proto::TaskStatus value) {
  assert(::tergeo::pipeline::proto::TaskStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:tergeo.pipeline.proto.Task.status)
}

// -------------------------------------------------------------------

// TaskList

// repeated .tergeo.pipeline.proto.Task task = 1;
inline int TaskList::task_size() const {
  return task_.size();
}
inline void TaskList::clear_task() {
  task_.Clear();
}
inline const ::tergeo::pipeline::proto::Task& TaskList::task(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.pipeline.proto.TaskList.task)
  return task_.Get(index);
}
inline ::tergeo::pipeline::proto::Task* TaskList::mutable_task(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.pipeline.proto.TaskList.task)
  return task_.Mutable(index);
}
inline ::tergeo::pipeline::proto::Task* TaskList::add_task() {
  // @@protoc_insertion_point(field_add:tergeo.pipeline.proto.TaskList.task)
  return task_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::pipeline::proto::Task >*
TaskList::mutable_task() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.pipeline.proto.TaskList.task)
  return &task_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::pipeline::proto::Task >&
TaskList::task() const {
  // @@protoc_insertion_point(field_list:tergeo.pipeline.proto.TaskList.task)
  return task_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace pipeline
}  // namespace tergeo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tergeo::pipeline::proto::TaskMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tergeo::pipeline::proto::TaskMode>() {
  return ::tergeo::pipeline::proto::TaskMode_descriptor();
}
template <> struct is_proto_enum< ::tergeo::pipeline::proto::TaskType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tergeo::pipeline::proto::TaskType>() {
  return ::tergeo::pipeline::proto::TaskType_descriptor();
}
template <> struct is_proto_enum< ::tergeo::pipeline::proto::TaskStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tergeo::pipeline::proto::TaskStatus>() {
  return ::tergeo::pipeline::proto::TaskStatus_descriptor();
}
template <> struct is_proto_enum< ::tergeo::pipeline::proto::SceneType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tergeo::pipeline::proto::SceneType>() {
  return ::tergeo::pipeline::proto::SceneType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tergeo_2fpipeline_2fproto_2ftask_2eproto__INCLUDED
