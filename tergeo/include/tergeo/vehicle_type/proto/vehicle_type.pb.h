// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tergeo/vehicle_type/proto/vehicle_type.proto

#ifndef PROTOBUF_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto__INCLUDED
#define PROTOBUF_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tergeo {
namespace vehicle_type {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
void protobuf_AssignDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
void protobuf_ShutdownFile_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();

class Arc;
class Point2d;
class Polygon;
class Rectangle;
class VehicleRegion;
class VehicleTypeConfig;

enum Type {
  TYPE_INCLUDE = 1,
  TYPE_EXCLUDE = 2
};
bool Type_IsValid(int value);
const Type Type_MIN = TYPE_INCLUDE;
const Type Type_MAX = TYPE_EXCLUDE;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class Point2d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.vehicle_type.proto.Point2d) */ {
 public:
  Point2d();
  virtual ~Point2d();

  Point2d(const Point2d& from);

  inline Point2d& operator=(const Point2d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point2d& default_instance();

  void Swap(Point2d* other);

  // implements Message ----------------------------------------------

  inline Point2d* New() const { return New(NULL); }

  Point2d* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point2d& from);
  void MergeFrom(const Point2d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point2d* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // @@protoc_insertion_point(class_scope:tergeo.vehicle_type.proto.Point2d)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  friend void  protobuf_AddDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();

  void InitAsDefaultInstance();
  static Point2d* default_instance_;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.vehicle_type.proto.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  void Swap(Polygon* other);

  // implements Message ----------------------------------------------

  inline Polygon* New() const { return New(NULL); }

  Polygon* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Polygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tergeo.vehicle_type.proto.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tergeo::vehicle_type::proto::Type type() const;
  void set_type(::tergeo::vehicle_type::proto::Type value);

  // repeated .tergeo.vehicle_type.proto.Point2d point = 2;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 2;
  const ::tergeo::vehicle_type::proto::Point2d& point(int index) const;
  ::tergeo::vehicle_type::proto::Point2d* mutable_point(int index);
  ::tergeo::vehicle_type::proto::Point2d* add_point();
  ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Point2d >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Point2d >&
      point() const;

  // optional bool enable = 3;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 3;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:tergeo.vehicle_type.proto.Polygon)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enable();
  inline void clear_has_enable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Point2d > point_;
  int type_;
  bool enable_;
  friend void  protobuf_AddDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();

  void InitAsDefaultInstance();
  static Polygon* default_instance_;
};
// -------------------------------------------------------------------

class Rectangle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.vehicle_type.proto.Rectangle) */ {
 public:
  Rectangle();
  virtual ~Rectangle();

  Rectangle(const Rectangle& from);

  inline Rectangle& operator=(const Rectangle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rectangle& default_instance();

  void Swap(Rectangle* other);

  // implements Message ----------------------------------------------

  inline Rectangle* New() const { return New(NULL); }

  Rectangle* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rectangle& from);
  void MergeFrom(const Rectangle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rectangle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tergeo.vehicle_type.proto.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tergeo::vehicle_type::proto::Type type() const;
  void set_type(::tergeo::vehicle_type::proto::Type value);

  // optional double min_x = 2;
  bool has_min_x() const;
  void clear_min_x();
  static const int kMinXFieldNumber = 2;
  double min_x() const;
  void set_min_x(double value);

  // optional double max_x = 3;
  bool has_max_x() const;
  void clear_max_x();
  static const int kMaxXFieldNumber = 3;
  double max_x() const;
  void set_max_x(double value);

  // optional double min_y = 4;
  bool has_min_y() const;
  void clear_min_y();
  static const int kMinYFieldNumber = 4;
  double min_y() const;
  void set_min_y(double value);

  // optional double max_y = 5;
  bool has_max_y() const;
  void clear_max_y();
  static const int kMaxYFieldNumber = 5;
  double max_y() const;
  void set_max_y(double value);

  // optional bool enable = 6;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 6;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:tergeo.vehicle_type.proto.Rectangle)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_min_x();
  inline void clear_has_min_x();
  inline void set_has_max_x();
  inline void clear_has_max_x();
  inline void set_has_min_y();
  inline void clear_has_min_y();
  inline void set_has_max_y();
  inline void clear_has_max_y();
  inline void set_has_enable();
  inline void clear_has_enable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double min_x_;
  double max_x_;
  int type_;
  bool enable_;
  double min_y_;
  double max_y_;
  friend void  protobuf_AddDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();

  void InitAsDefaultInstance();
  static Rectangle* default_instance_;
};
// -------------------------------------------------------------------

class Arc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.vehicle_type.proto.Arc) */ {
 public:
  Arc();
  virtual ~Arc();

  Arc(const Arc& from);

  inline Arc& operator=(const Arc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Arc& default_instance();

  void Swap(Arc* other);

  // implements Message ----------------------------------------------

  inline Arc* New() const { return New(NULL); }

  Arc* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Arc& from);
  void MergeFrom(const Arc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Arc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tergeo.vehicle_type.proto.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tergeo::vehicle_type::proto::Type type() const;
  void set_type(::tergeo::vehicle_type::proto::Type value);

  // optional .tergeo.vehicle_type.proto.Point2d center = 2;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 2;
  const ::tergeo::vehicle_type::proto::Point2d& center() const;
  ::tergeo::vehicle_type::proto::Point2d* mutable_center();
  ::tergeo::vehicle_type::proto::Point2d* release_center();
  void set_allocated_center(::tergeo::vehicle_type::proto::Point2d* center);

  // optional double radius = 3;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 3;
  double radius() const;
  void set_radius(double value);

  // optional int32 start_angle_deg = 4;
  bool has_start_angle_deg() const;
  void clear_start_angle_deg();
  static const int kStartAngleDegFieldNumber = 4;
  ::google::protobuf::int32 start_angle_deg() const;
  void set_start_angle_deg(::google::protobuf::int32 value);

  // optional int32 end_angle_deg = 5;
  bool has_end_angle_deg() const;
  void clear_end_angle_deg();
  static const int kEndAngleDegFieldNumber = 5;
  ::google::protobuf::int32 end_angle_deg() const;
  void set_end_angle_deg(::google::protobuf::int32 value);

  // optional bool enable = 6;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 6;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:tergeo.vehicle_type.proto.Arc)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_start_angle_deg();
  inline void clear_has_start_angle_deg();
  inline void set_has_end_angle_deg();
  inline void clear_has_end_angle_deg();
  inline void set_has_enable();
  inline void clear_has_enable();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tergeo::vehicle_type::proto::Point2d* center_;
  int type_;
  ::google::protobuf::int32 start_angle_deg_;
  double radius_;
  ::google::protobuf::int32 end_angle_deg_;
  bool enable_;
  friend void  protobuf_AddDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();

  void InitAsDefaultInstance();
  static Arc* default_instance_;
};
// -------------------------------------------------------------------

class VehicleRegion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.vehicle_type.proto.VehicleRegion) */ {
 public:
  VehicleRegion();
  virtual ~VehicleRegion();

  VehicleRegion(const VehicleRegion& from);

  inline VehicleRegion& operator=(const VehicleRegion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleRegion& default_instance();

  void Swap(VehicleRegion* other);

  // implements Message ----------------------------------------------

  inline VehicleRegion* New() const { return New(NULL); }

  VehicleRegion* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleRegion& from);
  void MergeFrom(const VehicleRegion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleRegion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tergeo.vehicle_type.proto.Polygon polygon = 1;
  int polygon_size() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 1;
  const ::tergeo::vehicle_type::proto::Polygon& polygon(int index) const;
  ::tergeo::vehicle_type::proto::Polygon* mutable_polygon(int index);
  ::tergeo::vehicle_type::proto::Polygon* add_polygon();
  ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Polygon >*
      mutable_polygon();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Polygon >&
      polygon() const;

  // repeated .tergeo.vehicle_type.proto.Rectangle rect = 2;
  int rect_size() const;
  void clear_rect();
  static const int kRectFieldNumber = 2;
  const ::tergeo::vehicle_type::proto::Rectangle& rect(int index) const;
  ::tergeo::vehicle_type::proto::Rectangle* mutable_rect(int index);
  ::tergeo::vehicle_type::proto::Rectangle* add_rect();
  ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Rectangle >*
      mutable_rect();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Rectangle >&
      rect() const;

  // repeated .tergeo.vehicle_type.proto.Arc arc = 3;
  int arc_size() const;
  void clear_arc();
  static const int kArcFieldNumber = 3;
  const ::tergeo::vehicle_type::proto::Arc& arc(int index) const;
  ::tergeo::vehicle_type::proto::Arc* mutable_arc(int index);
  ::tergeo::vehicle_type::proto::Arc* add_arc();
  ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Arc >*
      mutable_arc();
  const ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Arc >&
      arc() const;

  // @@protoc_insertion_point(class_scope:tergeo.vehicle_type.proto.VehicleRegion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Polygon > polygon_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Rectangle > rect_;
  ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Arc > arc_;
  friend void  protobuf_AddDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();

  void InitAsDefaultInstance();
  static VehicleRegion* default_instance_;
};
// -------------------------------------------------------------------

class VehicleTypeConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tergeo.vehicle_type.proto.VehicleTypeConfig) */ {
 public:
  VehicleTypeConfig();
  virtual ~VehicleTypeConfig();

  VehicleTypeConfig(const VehicleTypeConfig& from);

  inline VehicleTypeConfig& operator=(const VehicleTypeConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleTypeConfig& default_instance();

  void Swap(VehicleTypeConfig* other);

  // implements Message ----------------------------------------------

  inline VehicleTypeConfig* New() const { return New(NULL); }

  VehicleTypeConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleTypeConfig& from);
  void MergeFrom(const VehicleTypeConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleTypeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string vehicle_type = 1;
  bool has_vehicle_type() const;
  void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 1;
  const ::std::string& vehicle_type() const;
  void set_vehicle_type(const ::std::string& value);
  void set_vehicle_type(const char* value);
  void set_vehicle_type(const char* value, size_t size);
  ::std::string* mutable_vehicle_type();
  ::std::string* release_vehicle_type();
  void set_allocated_vehicle_type(::std::string* vehicle_type);

  // optional float height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  float height() const;
  void set_height(float value);

  // optional float wheelbase = 3;
  bool has_wheelbase() const;
  void clear_wheelbase();
  static const int kWheelbaseFieldNumber = 3;
  float wheelbase() const;
  void set_wheelbase(float value);

  // optional float min_turning_radius = 4;
  bool has_min_turning_radius() const;
  void clear_min_turning_radius();
  static const int kMinTurningRadiusFieldNumber = 4;
  float min_turning_radius() const;
  void set_min_turning_radius(float value);

  // optional string vehicle_model = 5;
  bool has_vehicle_model() const;
  void clear_vehicle_model();
  static const int kVehicleModelFieldNumber = 5;
  const ::std::string& vehicle_model() const;
  void set_vehicle_model(const ::std::string& value);
  void set_vehicle_model(const char* value);
  void set_vehicle_model(const char* value, size_t size);
  ::std::string* mutable_vehicle_model();
  ::std::string* release_vehicle_model();
  void set_allocated_vehicle_model(::std::string* vehicle_model);

  // optional .tergeo.vehicle_type.proto.Polygon vehicle_contour = 6;
  bool has_vehicle_contour() const;
  void clear_vehicle_contour();
  static const int kVehicleContourFieldNumber = 6;
  const ::tergeo::vehicle_type::proto::Polygon& vehicle_contour() const;
  ::tergeo::vehicle_type::proto::Polygon* mutable_vehicle_contour();
  ::tergeo::vehicle_type::proto::Polygon* release_vehicle_contour();
  void set_allocated_vehicle_contour(::tergeo::vehicle_type::proto::Polygon* vehicle_contour);

  // optional .tergeo.vehicle_type.proto.VehicleRegion emergency_region = 7;
  bool has_emergency_region() const;
  void clear_emergency_region();
  static const int kEmergencyRegionFieldNumber = 7;
  const ::tergeo::vehicle_type::proto::VehicleRegion& emergency_region() const;
  ::tergeo::vehicle_type::proto::VehicleRegion* mutable_emergency_region();
  ::tergeo::vehicle_type::proto::VehicleRegion* release_emergency_region();
  void set_allocated_emergency_region(::tergeo::vehicle_type::proto::VehicleRegion* emergency_region);

  // optional .tergeo.vehicle_type.proto.VehicleRegion trump_region = 8;
  bool has_trump_region() const;
  void clear_trump_region();
  static const int kTrumpRegionFieldNumber = 8;
  const ::tergeo::vehicle_type::proto::VehicleRegion& trump_region() const;
  ::tergeo::vehicle_type::proto::VehicleRegion* mutable_trump_region();
  ::tergeo::vehicle_type::proto::VehicleRegion* release_trump_region();
  void set_allocated_trump_region(::tergeo::vehicle_type::proto::VehicleRegion* trump_region);

  // @@protoc_insertion_point(class_scope:tergeo.vehicle_type.proto.VehicleTypeConfig)
 private:
  inline void set_has_vehicle_type();
  inline void clear_has_vehicle_type();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_wheelbase();
  inline void clear_has_wheelbase();
  inline void set_has_min_turning_radius();
  inline void clear_has_min_turning_radius();
  inline void set_has_vehicle_model();
  inline void clear_has_vehicle_model();
  inline void set_has_vehicle_contour();
  inline void clear_has_vehicle_contour();
  inline void set_has_emergency_region();
  inline void clear_has_emergency_region();
  inline void set_has_trump_region();
  inline void clear_has_trump_region();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr vehicle_type_;
  float height_;
  float wheelbase_;
  ::google::protobuf::internal::ArenaStringPtr vehicle_model_;
  ::tergeo::vehicle_type::proto::Polygon* vehicle_contour_;
  ::tergeo::vehicle_type::proto::VehicleRegion* emergency_region_;
  ::tergeo::vehicle_type::proto::VehicleRegion* trump_region_;
  float min_turning_radius_;
  friend void  protobuf_AddDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_AssignDesc_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();
  friend void protobuf_ShutdownFile_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto();

  void InitAsDefaultInstance();
  static VehicleTypeConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Point2d

// optional double x = 1;
inline bool Point2d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point2d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point2d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point2d::x() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Point2d.x)
  return x_;
}
inline void Point2d::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Point2d.x)
}

// optional double y = 2;
inline bool Point2d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point2d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point2d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point2d::y() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Point2d.y)
  return y_;
}
inline void Point2d::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Point2d.y)
}

// -------------------------------------------------------------------

// Polygon

// optional .tergeo.vehicle_type.proto.Type type = 1;
inline bool Polygon::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Polygon::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Polygon::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Polygon::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::tergeo::vehicle_type::proto::Type Polygon::type() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Polygon.type)
  return static_cast< ::tergeo::vehicle_type::proto::Type >(type_);
}
inline void Polygon::set_type(::tergeo::vehicle_type::proto::Type value) {
  assert(::tergeo::vehicle_type::proto::Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Polygon.type)
}

// repeated .tergeo.vehicle_type.proto.Point2d point = 2;
inline int Polygon::point_size() const {
  return point_.size();
}
inline void Polygon::clear_point() {
  point_.Clear();
}
inline const ::tergeo::vehicle_type::proto::Point2d& Polygon::point(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Polygon.point)
  return point_.Get(index);
}
inline ::tergeo::vehicle_type::proto::Point2d* Polygon::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.Polygon.point)
  return point_.Mutable(index);
}
inline ::tergeo::vehicle_type::proto::Point2d* Polygon::add_point() {
  // @@protoc_insertion_point(field_add:tergeo.vehicle_type.proto.Polygon.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Point2d >*
Polygon::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.vehicle_type.proto.Polygon.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Point2d >&
Polygon::point() const {
  // @@protoc_insertion_point(field_list:tergeo.vehicle_type.proto.Polygon.point)
  return point_;
}

// optional bool enable = 3;
inline bool Polygon::has_enable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Polygon::set_has_enable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Polygon::clear_has_enable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Polygon::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool Polygon::enable() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Polygon.enable)
  return enable_;
}
inline void Polygon::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Polygon.enable)
}

// -------------------------------------------------------------------

// Rectangle

// optional .tergeo.vehicle_type.proto.Type type = 1;
inline bool Rectangle::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rectangle::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rectangle::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rectangle::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::tergeo::vehicle_type::proto::Type Rectangle::type() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Rectangle.type)
  return static_cast< ::tergeo::vehicle_type::proto::Type >(type_);
}
inline void Rectangle::set_type(::tergeo::vehicle_type::proto::Type value) {
  assert(::tergeo::vehicle_type::proto::Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Rectangle.type)
}

// optional double min_x = 2;
inline bool Rectangle::has_min_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rectangle::set_has_min_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rectangle::clear_has_min_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rectangle::clear_min_x() {
  min_x_ = 0;
  clear_has_min_x();
}
inline double Rectangle::min_x() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Rectangle.min_x)
  return min_x_;
}
inline void Rectangle::set_min_x(double value) {
  set_has_min_x();
  min_x_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Rectangle.min_x)
}

// optional double max_x = 3;
inline bool Rectangle::has_max_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rectangle::set_has_max_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rectangle::clear_has_max_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rectangle::clear_max_x() {
  max_x_ = 0;
  clear_has_max_x();
}
inline double Rectangle::max_x() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Rectangle.max_x)
  return max_x_;
}
inline void Rectangle::set_max_x(double value) {
  set_has_max_x();
  max_x_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Rectangle.max_x)
}

// optional double min_y = 4;
inline bool Rectangle::has_min_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rectangle::set_has_min_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rectangle::clear_has_min_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rectangle::clear_min_y() {
  min_y_ = 0;
  clear_has_min_y();
}
inline double Rectangle::min_y() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Rectangle.min_y)
  return min_y_;
}
inline void Rectangle::set_min_y(double value) {
  set_has_min_y();
  min_y_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Rectangle.min_y)
}

// optional double max_y = 5;
inline bool Rectangle::has_max_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Rectangle::set_has_max_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Rectangle::clear_has_max_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Rectangle::clear_max_y() {
  max_y_ = 0;
  clear_has_max_y();
}
inline double Rectangle::max_y() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Rectangle.max_y)
  return max_y_;
}
inline void Rectangle::set_max_y(double value) {
  set_has_max_y();
  max_y_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Rectangle.max_y)
}

// optional bool enable = 6;
inline bool Rectangle::has_enable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Rectangle::set_has_enable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Rectangle::clear_has_enable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Rectangle::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool Rectangle::enable() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Rectangle.enable)
  return enable_;
}
inline void Rectangle::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Rectangle.enable)
}

// -------------------------------------------------------------------

// Arc

// optional .tergeo.vehicle_type.proto.Type type = 1;
inline bool Arc::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Arc::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Arc::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Arc::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::tergeo::vehicle_type::proto::Type Arc::type() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Arc.type)
  return static_cast< ::tergeo::vehicle_type::proto::Type >(type_);
}
inline void Arc::set_type(::tergeo::vehicle_type::proto::Type value) {
  assert(::tergeo::vehicle_type::proto::Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Arc.type)
}

// optional .tergeo.vehicle_type.proto.Point2d center = 2;
inline bool Arc::has_center() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Arc::set_has_center() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Arc::clear_has_center() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Arc::clear_center() {
  if (center_ != NULL) center_->::tergeo::vehicle_type::proto::Point2d::Clear();
  clear_has_center();
}
inline const ::tergeo::vehicle_type::proto::Point2d& Arc::center() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Arc.center)
  return center_ != NULL ? *center_ : *default_instance_->center_;
}
inline ::tergeo::vehicle_type::proto::Point2d* Arc::mutable_center() {
  set_has_center();
  if (center_ == NULL) {
    center_ = new ::tergeo::vehicle_type::proto::Point2d;
  }
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.Arc.center)
  return center_;
}
inline ::tergeo::vehicle_type::proto::Point2d* Arc::release_center() {
  // @@protoc_insertion_point(field_release:tergeo.vehicle_type.proto.Arc.center)
  clear_has_center();
  ::tergeo::vehicle_type::proto::Point2d* temp = center_;
  center_ = NULL;
  return temp;
}
inline void Arc::set_allocated_center(::tergeo::vehicle_type::proto::Point2d* center) {
  delete center_;
  center_ = center;
  if (center) {
    set_has_center();
  } else {
    clear_has_center();
  }
  // @@protoc_insertion_point(field_set_allocated:tergeo.vehicle_type.proto.Arc.center)
}

// optional double radius = 3;
inline bool Arc::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Arc::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Arc::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Arc::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double Arc::radius() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Arc.radius)
  return radius_;
}
inline void Arc::set_radius(double value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Arc.radius)
}

// optional int32 start_angle_deg = 4;
inline bool Arc::has_start_angle_deg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Arc::set_has_start_angle_deg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Arc::clear_has_start_angle_deg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Arc::clear_start_angle_deg() {
  start_angle_deg_ = 0;
  clear_has_start_angle_deg();
}
inline ::google::protobuf::int32 Arc::start_angle_deg() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Arc.start_angle_deg)
  return start_angle_deg_;
}
inline void Arc::set_start_angle_deg(::google::protobuf::int32 value) {
  set_has_start_angle_deg();
  start_angle_deg_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Arc.start_angle_deg)
}

// optional int32 end_angle_deg = 5;
inline bool Arc::has_end_angle_deg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Arc::set_has_end_angle_deg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Arc::clear_has_end_angle_deg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Arc::clear_end_angle_deg() {
  end_angle_deg_ = 0;
  clear_has_end_angle_deg();
}
inline ::google::protobuf::int32 Arc::end_angle_deg() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Arc.end_angle_deg)
  return end_angle_deg_;
}
inline void Arc::set_end_angle_deg(::google::protobuf::int32 value) {
  set_has_end_angle_deg();
  end_angle_deg_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Arc.end_angle_deg)
}

// optional bool enable = 6;
inline bool Arc::has_enable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Arc::set_has_enable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Arc::clear_has_enable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Arc::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool Arc::enable() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.Arc.enable)
  return enable_;
}
inline void Arc::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.Arc.enable)
}

// -------------------------------------------------------------------

// VehicleRegion

// repeated .tergeo.vehicle_type.proto.Polygon polygon = 1;
inline int VehicleRegion::polygon_size() const {
  return polygon_.size();
}
inline void VehicleRegion::clear_polygon() {
  polygon_.Clear();
}
inline const ::tergeo::vehicle_type::proto::Polygon& VehicleRegion::polygon(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleRegion.polygon)
  return polygon_.Get(index);
}
inline ::tergeo::vehicle_type::proto::Polygon* VehicleRegion::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.VehicleRegion.polygon)
  return polygon_.Mutable(index);
}
inline ::tergeo::vehicle_type::proto::Polygon* VehicleRegion::add_polygon() {
  // @@protoc_insertion_point(field_add:tergeo.vehicle_type.proto.VehicleRegion.polygon)
  return polygon_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Polygon >*
VehicleRegion::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.vehicle_type.proto.VehicleRegion.polygon)
  return &polygon_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Polygon >&
VehicleRegion::polygon() const {
  // @@protoc_insertion_point(field_list:tergeo.vehicle_type.proto.VehicleRegion.polygon)
  return polygon_;
}

// repeated .tergeo.vehicle_type.proto.Rectangle rect = 2;
inline int VehicleRegion::rect_size() const {
  return rect_.size();
}
inline void VehicleRegion::clear_rect() {
  rect_.Clear();
}
inline const ::tergeo::vehicle_type::proto::Rectangle& VehicleRegion::rect(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleRegion.rect)
  return rect_.Get(index);
}
inline ::tergeo::vehicle_type::proto::Rectangle* VehicleRegion::mutable_rect(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.VehicleRegion.rect)
  return rect_.Mutable(index);
}
inline ::tergeo::vehicle_type::proto::Rectangle* VehicleRegion::add_rect() {
  // @@protoc_insertion_point(field_add:tergeo.vehicle_type.proto.VehicleRegion.rect)
  return rect_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Rectangle >*
VehicleRegion::mutable_rect() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.vehicle_type.proto.VehicleRegion.rect)
  return &rect_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Rectangle >&
VehicleRegion::rect() const {
  // @@protoc_insertion_point(field_list:tergeo.vehicle_type.proto.VehicleRegion.rect)
  return rect_;
}

// repeated .tergeo.vehicle_type.proto.Arc arc = 3;
inline int VehicleRegion::arc_size() const {
  return arc_.size();
}
inline void VehicleRegion::clear_arc() {
  arc_.Clear();
}
inline const ::tergeo::vehicle_type::proto::Arc& VehicleRegion::arc(int index) const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleRegion.arc)
  return arc_.Get(index);
}
inline ::tergeo::vehicle_type::proto::Arc* VehicleRegion::mutable_arc(int index) {
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.VehicleRegion.arc)
  return arc_.Mutable(index);
}
inline ::tergeo::vehicle_type::proto::Arc* VehicleRegion::add_arc() {
  // @@protoc_insertion_point(field_add:tergeo.vehicle_type.proto.VehicleRegion.arc)
  return arc_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Arc >*
VehicleRegion::mutable_arc() {
  // @@protoc_insertion_point(field_mutable_list:tergeo.vehicle_type.proto.VehicleRegion.arc)
  return &arc_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tergeo::vehicle_type::proto::Arc >&
VehicleRegion::arc() const {
  // @@protoc_insertion_point(field_list:tergeo.vehicle_type.proto.VehicleRegion.arc)
  return arc_;
}

// -------------------------------------------------------------------

// VehicleTypeConfig

// optional string vehicle_type = 1;
inline bool VehicleTypeConfig::has_vehicle_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleTypeConfig::set_has_vehicle_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleTypeConfig::clear_has_vehicle_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleTypeConfig::clear_vehicle_type() {
  vehicle_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicle_type();
}
inline const ::std::string& VehicleTypeConfig::vehicle_type() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_type)
  return vehicle_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleTypeConfig::set_vehicle_type(const ::std::string& value) {
  set_has_vehicle_type();
  vehicle_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_type)
}
inline void VehicleTypeConfig::set_vehicle_type(const char* value) {
  set_has_vehicle_type();
  vehicle_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_type)
}
inline void VehicleTypeConfig::set_vehicle_type(const char* value, size_t size) {
  set_has_vehicle_type();
  vehicle_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_type)
}
inline ::std::string* VehicleTypeConfig::mutable_vehicle_type() {
  set_has_vehicle_type();
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_type)
  return vehicle_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleTypeConfig::release_vehicle_type() {
  // @@protoc_insertion_point(field_release:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_type)
  clear_has_vehicle_type();
  return vehicle_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleTypeConfig::set_allocated_vehicle_type(::std::string* vehicle_type) {
  if (vehicle_type != NULL) {
    set_has_vehicle_type();
  } else {
    clear_has_vehicle_type();
  }
  vehicle_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicle_type);
  // @@protoc_insertion_point(field_set_allocated:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_type)
}

// optional float height = 2;
inline bool VehicleTypeConfig::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleTypeConfig::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleTypeConfig::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleTypeConfig::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float VehicleTypeConfig::height() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleTypeConfig.height)
  return height_;
}
inline void VehicleTypeConfig::set_height(float value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.VehicleTypeConfig.height)
}

// optional float wheelbase = 3;
inline bool VehicleTypeConfig::has_wheelbase() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleTypeConfig::set_has_wheelbase() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleTypeConfig::clear_has_wheelbase() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleTypeConfig::clear_wheelbase() {
  wheelbase_ = 0;
  clear_has_wheelbase();
}
inline float VehicleTypeConfig::wheelbase() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleTypeConfig.wheelbase)
  return wheelbase_;
}
inline void VehicleTypeConfig::set_wheelbase(float value) {
  set_has_wheelbase();
  wheelbase_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.VehicleTypeConfig.wheelbase)
}

// optional float min_turning_radius = 4;
inline bool VehicleTypeConfig::has_min_turning_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehicleTypeConfig::set_has_min_turning_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehicleTypeConfig::clear_has_min_turning_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehicleTypeConfig::clear_min_turning_radius() {
  min_turning_radius_ = 0;
  clear_has_min_turning_radius();
}
inline float VehicleTypeConfig::min_turning_radius() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleTypeConfig.min_turning_radius)
  return min_turning_radius_;
}
inline void VehicleTypeConfig::set_min_turning_radius(float value) {
  set_has_min_turning_radius();
  min_turning_radius_ = value;
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.VehicleTypeConfig.min_turning_radius)
}

// optional string vehicle_model = 5;
inline bool VehicleTypeConfig::has_vehicle_model() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehicleTypeConfig::set_has_vehicle_model() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehicleTypeConfig::clear_has_vehicle_model() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehicleTypeConfig::clear_vehicle_model() {
  vehicle_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_vehicle_model();
}
inline const ::std::string& VehicleTypeConfig::vehicle_model() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_model)
  return vehicle_model_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleTypeConfig::set_vehicle_model(const ::std::string& value) {
  set_has_vehicle_model();
  vehicle_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_model)
}
inline void VehicleTypeConfig::set_vehicle_model(const char* value) {
  set_has_vehicle_model();
  vehicle_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_model)
}
inline void VehicleTypeConfig::set_vehicle_model(const char* value, size_t size) {
  set_has_vehicle_model();
  vehicle_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_model)
}
inline ::std::string* VehicleTypeConfig::mutable_vehicle_model() {
  set_has_vehicle_model();
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_model)
  return vehicle_model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleTypeConfig::release_vehicle_model() {
  // @@protoc_insertion_point(field_release:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_model)
  clear_has_vehicle_model();
  return vehicle_model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleTypeConfig::set_allocated_vehicle_model(::std::string* vehicle_model) {
  if (vehicle_model != NULL) {
    set_has_vehicle_model();
  } else {
    clear_has_vehicle_model();
  }
  vehicle_model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vehicle_model);
  // @@protoc_insertion_point(field_set_allocated:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_model)
}

// optional .tergeo.vehicle_type.proto.Polygon vehicle_contour = 6;
inline bool VehicleTypeConfig::has_vehicle_contour() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehicleTypeConfig::set_has_vehicle_contour() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehicleTypeConfig::clear_has_vehicle_contour() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehicleTypeConfig::clear_vehicle_contour() {
  if (vehicle_contour_ != NULL) vehicle_contour_->::tergeo::vehicle_type::proto::Polygon::Clear();
  clear_has_vehicle_contour();
}
inline const ::tergeo::vehicle_type::proto::Polygon& VehicleTypeConfig::vehicle_contour() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_contour)
  return vehicle_contour_ != NULL ? *vehicle_contour_ : *default_instance_->vehicle_contour_;
}
inline ::tergeo::vehicle_type::proto::Polygon* VehicleTypeConfig::mutable_vehicle_contour() {
  set_has_vehicle_contour();
  if (vehicle_contour_ == NULL) {
    vehicle_contour_ = new ::tergeo::vehicle_type::proto::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_contour)
  return vehicle_contour_;
}
inline ::tergeo::vehicle_type::proto::Polygon* VehicleTypeConfig::release_vehicle_contour() {
  // @@protoc_insertion_point(field_release:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_contour)
  clear_has_vehicle_contour();
  ::tergeo::vehicle_type::proto::Polygon* temp = vehicle_contour_;
  vehicle_contour_ = NULL;
  return temp;
}
inline void VehicleTypeConfig::set_allocated_vehicle_contour(::tergeo::vehicle_type::proto::Polygon* vehicle_contour) {
  delete vehicle_contour_;
  vehicle_contour_ = vehicle_contour;
  if (vehicle_contour) {
    set_has_vehicle_contour();
  } else {
    clear_has_vehicle_contour();
  }
  // @@protoc_insertion_point(field_set_allocated:tergeo.vehicle_type.proto.VehicleTypeConfig.vehicle_contour)
}

// optional .tergeo.vehicle_type.proto.VehicleRegion emergency_region = 7;
inline bool VehicleTypeConfig::has_emergency_region() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehicleTypeConfig::set_has_emergency_region() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehicleTypeConfig::clear_has_emergency_region() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehicleTypeConfig::clear_emergency_region() {
  if (emergency_region_ != NULL) emergency_region_->::tergeo::vehicle_type::proto::VehicleRegion::Clear();
  clear_has_emergency_region();
}
inline const ::tergeo::vehicle_type::proto::VehicleRegion& VehicleTypeConfig::emergency_region() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleTypeConfig.emergency_region)
  return emergency_region_ != NULL ? *emergency_region_ : *default_instance_->emergency_region_;
}
inline ::tergeo::vehicle_type::proto::VehicleRegion* VehicleTypeConfig::mutable_emergency_region() {
  set_has_emergency_region();
  if (emergency_region_ == NULL) {
    emergency_region_ = new ::tergeo::vehicle_type::proto::VehicleRegion;
  }
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.VehicleTypeConfig.emergency_region)
  return emergency_region_;
}
inline ::tergeo::vehicle_type::proto::VehicleRegion* VehicleTypeConfig::release_emergency_region() {
  // @@protoc_insertion_point(field_release:tergeo.vehicle_type.proto.VehicleTypeConfig.emergency_region)
  clear_has_emergency_region();
  ::tergeo::vehicle_type::proto::VehicleRegion* temp = emergency_region_;
  emergency_region_ = NULL;
  return temp;
}
inline void VehicleTypeConfig::set_allocated_emergency_region(::tergeo::vehicle_type::proto::VehicleRegion* emergency_region) {
  delete emergency_region_;
  emergency_region_ = emergency_region;
  if (emergency_region) {
    set_has_emergency_region();
  } else {
    clear_has_emergency_region();
  }
  // @@protoc_insertion_point(field_set_allocated:tergeo.vehicle_type.proto.VehicleTypeConfig.emergency_region)
}

// optional .tergeo.vehicle_type.proto.VehicleRegion trump_region = 8;
inline bool VehicleTypeConfig::has_trump_region() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehicleTypeConfig::set_has_trump_region() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehicleTypeConfig::clear_has_trump_region() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehicleTypeConfig::clear_trump_region() {
  if (trump_region_ != NULL) trump_region_->::tergeo::vehicle_type::proto::VehicleRegion::Clear();
  clear_has_trump_region();
}
inline const ::tergeo::vehicle_type::proto::VehicleRegion& VehicleTypeConfig::trump_region() const {
  // @@protoc_insertion_point(field_get:tergeo.vehicle_type.proto.VehicleTypeConfig.trump_region)
  return trump_region_ != NULL ? *trump_region_ : *default_instance_->trump_region_;
}
inline ::tergeo::vehicle_type::proto::VehicleRegion* VehicleTypeConfig::mutable_trump_region() {
  set_has_trump_region();
  if (trump_region_ == NULL) {
    trump_region_ = new ::tergeo::vehicle_type::proto::VehicleRegion;
  }
  // @@protoc_insertion_point(field_mutable:tergeo.vehicle_type.proto.VehicleTypeConfig.trump_region)
  return trump_region_;
}
inline ::tergeo::vehicle_type::proto::VehicleRegion* VehicleTypeConfig::release_trump_region() {
  // @@protoc_insertion_point(field_release:tergeo.vehicle_type.proto.VehicleTypeConfig.trump_region)
  clear_has_trump_region();
  ::tergeo::vehicle_type::proto::VehicleRegion* temp = trump_region_;
  trump_region_ = NULL;
  return temp;
}
inline void VehicleTypeConfig::set_allocated_trump_region(::tergeo::vehicle_type::proto::VehicleRegion* trump_region) {
  delete trump_region_;
  trump_region_ = trump_region;
  if (trump_region) {
    set_has_trump_region();
  } else {
    clear_has_trump_region();
  }
  // @@protoc_insertion_point(field_set_allocated:tergeo.vehicle_type.proto.VehicleTypeConfig.trump_region)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace vehicle_type
}  // namespace tergeo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tergeo::vehicle_type::proto::Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tergeo::vehicle_type::proto::Type>() {
  return ::tergeo::vehicle_type::proto::Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tergeo_2fvehicle_5ftype_2fproto_2fvehicle_5ftype_2eproto__INCLUDED
